{"version":3,"file":"index.es5.js","sources":["../src/utils.ts","../src/ast.ts","../src/RewriteHandler.ts","../src/rewriters/Rewriter.ts","../src/rewriters/FieldArgNameRewriter.ts","../src/rewriters/FieldArgsToInputTypeRewriter.ts","../src/rewriters/FieldArgTypeRewriter.ts","../src/rewriters/NestFieldOutputsRewriter.ts","../src/rewriters/ScalarFieldToObjectFieldRewriter.ts","../src/rewriters/JsonToTypedObjectRewriter.ts","../src/matchConditions/fragmentMatchCondition.ts","../src/matchConditions/operationMatchCondition.ts","../src/matchConditions/queryMatchCondition.ts","../src/matchConditions/mutationMatchCondition.ts"],"sourcesContent":["/** @hidden */\r\nexport const identifyFunc = <T>(val: T) => val;\r\n\r\n/** @hidden */\r\nexport const pushToArrayAtKey = <T>(mapping: { [key: string]: T[] }, key: string, val: T): void => {\r\n  if (!mapping[key]) mapping[key] = [];\r\n  mapping[key].push(val);\r\n};\r\n","import { ASTNode, DocumentNode, FragmentDefinitionNode, VariableDefinitionNode } from 'graphql';\nimport { pushToArrayAtKey } from './utils';\n\nconst ignoreKeys = new Set(['loc']);\n\n/** @hidden */\nexport const nodesMatch = (node1: ASTNode, node2: ASTNode): boolean => {\n  for (const key of Object.keys(node1)) {\n    if (ignoreKeys.has(key)) continue;\n    const val1 = (node1 as any)[key];\n    const val2 = (node2 as any)[key];\n    if (val1 && !val2) return false;\n    if (Array.isArray(val1)) {\n      if (val1.length !== val2.length) return false;\n      for (let i = 0; i < val1.length; i++) {\n        if (!nodesMatch(val1[i], val2[i])) return false;\n      }\n    } else if (typeof val1 === 'object') {\n      if (!nodesMatch(val1, val2)) return false;\n    } else if (val1 !== val2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/** @hidden */\nexport interface NodeAndVarDefs {\n  node: ASTNode;\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>;\n}\n\n/** @hidden */\nexport interface FragmentPathMap {\n  [fragmentName: string]: ReadonlyArray<ReadonlyArray<string>>;\n}\n\n/** @hidden */\ninterface MutableFragmentPathMap {\n  [fragmentName: string]: Array<ReadonlyArray<string>>;\n}\n\n/** @hidden */\nexport class FragmentTracer {\n  private fragmentPathMap?: FragmentPathMap;\n  private doc: DocumentNode;\n\n  constructor(doc: DocumentNode) {\n    this.doc = doc;\n  }\n\n  public getPathsToFragment(fragmentName: string): ReadonlyArray<ReadonlyArray<string>> {\n    if (!this.fragmentPathMap) {\n      this.fragmentPathMap = this.buildFragmentPathMap();\n    }\n    return this.fragmentPathMap[fragmentName] || [];\n  }\n\n  // prepend the paths from the original document into this fragment to the inner fragment paths\n  public prependFragmentPaths(\n    fragmentName: string,\n    pathWithinFragment: ReadonlyArray<string>\n  ): ReadonlyArray<ReadonlyArray<string>> {\n    return this.getPathsToFragment(fragmentName).map(path => [...path, ...pathWithinFragment]);\n  }\n\n  private getFragmentDefs(): ReadonlyArray<FragmentDefinitionNode> {\n    return this.doc.definitions.filter(\n      ({ kind }) => kind === 'FragmentDefinition'\n    ) as FragmentDefinitionNode[];\n  }\n\n  private getFragmentPartialPathMap(startNode: ASTNode): MutableFragmentPathMap {\n    const partialPathMap: MutableFragmentPathMap = {};\n    const recursivelyBuildFragmentPaths = (node: ASTNode, curParents: ReadonlyArray<ASTNode>) => {\n      if (node.kind === 'FragmentSpread') {\n        pushToArrayAtKey(partialPathMap, node.name.value, extractPath(curParents));\n      }\n      const nextParents = [...curParents, node];\n      if ('selectionSet' in node && node.selectionSet) {\n        for (const selection of node.selectionSet.selections) {\n          recursivelyBuildFragmentPaths(selection, nextParents);\n        }\n      }\n    };\n    recursivelyBuildFragmentPaths(startNode, []);\n    return partialPathMap;\n  }\n\n  private mergeFragmentPaths(\n    fragmentName: string,\n    paths: Array<ReadonlyArray<string>>,\n    fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap }\n  ) {\n    const mergedPaths: MutableFragmentPathMap = {};\n\n    const resursivelyBuildMergedPathsMap = (\n      curFragmentName: string,\n      curPaths: Array<ReadonlyArray<string>>,\n      seenFragments: ReadonlySet<string>\n    ) => {\n      // recursive fragments are invalid graphQL - just exit here. otherwise this will be an infinite loop\n      if (seenFragments.has(curFragmentName)) return;\n      const nextSeenFragments = new Set(seenFragments);\n      nextSeenFragments.add(curFragmentName);\n      const nextPartialPaths = fragmentPartialPathsMap[curFragmentName];\n      // if there are not other fragments nested inside of this fragment, we're done\n      if (!nextPartialPaths) return;\n\n      for (const [childFragmentName, childFragmentPaths] of Object.entries(nextPartialPaths)) {\n        for (const path of curPaths) {\n          const mergedChildPaths: Array<ReadonlyArray<string>> = [];\n          for (const childPath of childFragmentPaths) {\n            const mergedPath = [...path, ...childPath];\n            mergedChildPaths.push(mergedPath);\n            pushToArrayAtKey(mergedPaths, childFragmentName, mergedPath);\n          }\n          resursivelyBuildMergedPathsMap(childFragmentName, mergedChildPaths, nextSeenFragments);\n        }\n      }\n    };\n\n    resursivelyBuildMergedPathsMap(fragmentName, paths, new Set());\n    return mergedPaths;\n  }\n\n  private buildFragmentPathMap(): FragmentPathMap {\n    const mainOperation = this.doc.definitions.find(node => node.kind === 'OperationDefinition');\n    if (!mainOperation) return {};\n\n    // partial paths are the paths inside of each fragmnt to other fragments\n    const fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap } = {};\n    for (const fragmentDef of this.getFragmentDefs()) {\n      fragmentPartialPathsMap[fragmentDef.name.value] = this.getFragmentPartialPathMap(fragmentDef);\n    }\n\n    // start with the direct paths to fragments inside of the main operation\n    const simpleFragmentPathMap: MutableFragmentPathMap = this.getFragmentPartialPathMap(\n      mainOperation\n    );\n    const fragmentPathMap: MutableFragmentPathMap = { ...simpleFragmentPathMap };\n    // next, we'll recursively trace the partials into their subpartials to fill out all possible paths to each fragment\n    for (const [fragmentName, simplePaths] of Object.entries(simpleFragmentPathMap)) {\n      const mergedFragmentPathsMap = this.mergeFragmentPaths(\n        fragmentName,\n        simplePaths,\n        fragmentPartialPathsMap\n      );\n      for (const [mergedFragmentName, mergedFragmentPaths] of Object.entries(\n        mergedFragmentPathsMap\n      )) {\n        fragmentPathMap[mergedFragmentName] = [\n          ...(fragmentPathMap[mergedFragmentName] || []),\n          ...mergedFragmentPaths\n        ];\n      }\n    }\n\n    return fragmentPathMap;\n  }\n}\n\n/**\n * Walk the document add rewrite nodes along the way\n * @param doc\n * @param callback Called on each node, and returns a new rewritten node\n * @hidden\n */\nexport const rewriteDoc = (\n  doc: DocumentNode,\n  callback: (nodeAndVars: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>) => NodeAndVarDefs\n): DocumentNode => {\n  let variableDefinitions = extractVariableDefinitions(doc);\n  const walkRecursive = (\n    curNodeAndVars: NodeAndVarDefs,\n    curParents: ReadonlyArray<ASTNode>\n  ): ASTNode => {\n    const nextNodeAndVars = callback(curNodeAndVars, curParents);\n    variableDefinitions = nextNodeAndVars.variableDefinitions;\n    const node = nextNodeAndVars.node;\n    const nextParents = [...curParents, node];\n    for (const key of Object.keys(node)) {\n      if (key === 'loc') continue;\n      const val = (node as any)[key];\n      if (Array.isArray(val)) {\n        (node as any)[key] = val.map(elm => {\n          if (typeof elm === 'object') {\n            const next: NodeAndVarDefs = {\n              variableDefinitions,\n              node: elm\n            };\n            return walkRecursive(next, nextParents);\n          }\n          return elm;\n        });\n      } else if (typeof val === 'object') {\n        const next: NodeAndVarDefs = {\n          variableDefinitions,\n          node: val\n        };\n        (node as any)[key] = walkRecursive(next, nextParents);\n      }\n    }\n    return node;\n  };\n\n  const root: NodeAndVarDefs = {\n    variableDefinitions,\n    node: doc\n  };\n  const rewrittenDoc = walkRecursive(root, []) as DocumentNode;\n  return replaceVariableDefinitions(rewrittenDoc, variableDefinitions);\n};\n\n/** @hidden */\nexport const extractVariableDefinitions = (\n  doc: DocumentNode\n): ReadonlyArray<VariableDefinitionNode> => {\n  for (const def of doc.definitions) {\n    if (def.kind === 'OperationDefinition') {\n      return def.variableDefinitions || [];\n    }\n  }\n  return [];\n};\n\n/** @hidden */\nexport const replaceVariableDefinitions = (\n  doc: DocumentNode,\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>\n): DocumentNode => {\n  const definitions = doc.definitions.map(def => {\n    if (def.kind === 'OperationDefinition') {\n      return { ...def, variableDefinitions };\n    }\n    return def;\n  });\n  return { ...doc, definitions };\n};\n\n/**\n * return the path that will be returned in the response from from the chain of parents\n */\n/** @hidden */\nexport const extractPath = (parents: ReadonlyArray<ASTNode>): ReadonlyArray<string> => {\n  const path: string[] = [];\n  parents.forEach(parent => {\n    if (parent.kind === 'Field') {\n      path.push(parent.name.value);\n    }\n  });\n  return path;\n};\n\n/** @hidden */\ninterface ResultObj {\n  [key: string]: any;\n}\n\n/** @hidden */\nexport const rewriteResultsAtPath = (\n  results: ResultObj,\n  path: ReadonlyArray<string>,\n  callback: (parentResult: any, key: string | number) => any\n): ResultObj => {\n  if (path.length === 0) return results;\n\n  const curPathElm = path[0];\n  const newResults = { ...results };\n  const curResults = results[curPathElm];\n\n  if (path.length === 1) {\n    if (Array.isArray(curResults)) {\n      return curResults.map((_, index) => {\n        const newValue = callback(curResults, index);\n        return newValue;\n      });\n    }\n\n    return callback(results, curPathElm);\n  }\n\n  const remainingPath = path.slice(1);\n  // if the path stops here, just return results without any rewriting\n  if (curResults === undefined || curResults === null) return results;\n\n  if (Array.isArray(curResults)) {\n    newResults[curPathElm] = curResults.map(result =>\n      rewriteResultsAtPath(result, remainingPath, callback)\n    );\n  } else {\n    newResults[curPathElm] = rewriteResultsAtPath(curResults, remainingPath, callback);\n  }\n\n  return newResults;\n};\n","import { FragmentDefinitionNode, parse, print } from 'graphql';\r\nimport { extractPath, FragmentTracer, rewriteDoc, rewriteResultsAtPath } from './ast';\r\nimport Rewriter, { Variables } from './rewriters/Rewriter';\r\n\r\ninterface RewriterMatch {\r\n  rewriter: Rewriter;\r\n  paths: ReadonlyArray<ReadonlyArray<string>>;\r\n}\r\n\r\n/**\r\n * Create a new instance of this class for each request that needs to be processed\r\n * This class handles rewriting the query and the reponse according to the rewriters passed in\r\n */\r\nexport default class RewriteHandler {\r\n  public matches: RewriterMatch[] = [];\r\n\r\n  private rewriters: Rewriter[];\r\n  private hasProcessedRequest: boolean = false;\r\n  private hasProcessedResponse: boolean = false;\r\n\r\n  constructor(rewriters: Rewriter[]) {\r\n    this.rewriters = rewriters;\r\n  }\r\n\r\n  /**\r\n   * Call this on a graphQL request in middleware before passing on to the real graphql processor\r\n   * @param query The graphQL query\r\n   * @param variables The variables map for the graphQL query\r\n   */\r\n  public rewriteRequest(query: string, variables?: Variables) {\r\n    if (this.hasProcessedRequest) throw new Error('This handler has already rewritten a request');\r\n    this.hasProcessedRequest = true;\r\n    const doc = parse(query);\r\n    const fragmentTracer = new FragmentTracer(doc);\r\n    let rewrittenVariables = variables;\r\n    const rewrittenDoc = rewriteDoc(doc, (nodeAndVars, parents) => {\r\n      let rewrittenNodeAndVars = nodeAndVars;\r\n      this.rewriters.forEach(rewriter => {\r\n        const isMatch = rewriter.matches(nodeAndVars, parents);\r\n        if (isMatch) {\r\n          rewrittenVariables = rewriter.rewriteVariables(rewrittenNodeAndVars, rewrittenVariables);\r\n          rewrittenNodeAndVars = rewriter.rewriteQuery(rewrittenNodeAndVars);\r\n          const simplePath = extractPath([...parents, rewrittenNodeAndVars.node]);\r\n          let paths: ReadonlyArray<ReadonlyArray<string>> = [simplePath];\r\n          const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\r\n            | FragmentDefinitionNode\r\n            | undefined;\r\n          if (fragmentDef) {\r\n            paths = fragmentTracer.prependFragmentPaths(fragmentDef.name.value, simplePath);\r\n          }\r\n          this.matches.push({\r\n            rewriter,\r\n            paths\r\n          });\r\n        }\r\n        return isMatch;\r\n      });\r\n      return rewrittenNodeAndVars;\r\n    });\r\n\r\n    return { query: print(rewrittenDoc), variables: rewrittenVariables };\r\n  }\r\n\r\n  /**\r\n   * Call this on the response returned from graphQL before passing it back to the client\r\n   * This will change the output to match what the original query requires\r\n   * @param response The graphQL response object\r\n   */\r\n  public rewriteResponse(response: any) {\r\n    if (this.hasProcessedResponse) throw new Error('This handler has already returned a response');\r\n    this.hasProcessedResponse = true;\r\n    let rewrittenResponse = response;\r\n    this.matches.reverse().forEach(({ rewriter, paths }) => {\r\n      paths.forEach(path => {\r\n        rewrittenResponse = rewriteResultsAtPath(rewrittenResponse, path, (parentResponse, key) =>\r\n          rewriter.rewriteResponse(parentResponse, key)\r\n        );\r\n      });\r\n    });\r\n    return rewrittenResponse;\r\n  }\r\n}\r\n","import { ASTNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport matchCondition from '../matchConditions/matchCondition';\n\nexport type Variables = { [key: string]: any } | undefined;\nexport type RootType = 'query' | 'mutation' | 'fragment';\n\nexport interface RewriterOpts {\n  fieldName: string;\n  rootTypes?: RootType[];\n  matchConditions?: matchCondition[];\n}\n\n/**\n * Abstract base Rewriter class\n * Extend this class and overwrite its methods to create a new rewriter\n */\nabstract class Rewriter {\n  protected fieldName: string;\n  protected rootTypes: RootType[] = ['query', 'mutation', 'fragment'];\n  protected matchConditions?: matchCondition[];\n\n  constructor({ fieldName, rootTypes, matchConditions }: RewriterOpts) {\n    this.fieldName = fieldName;\n    this.matchConditions = matchConditions;\n    if (rootTypes) this.rootTypes = rootTypes;\n  }\n\n  public matches(nodeAndVarDefs: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>): boolean {\n    const { node } = nodeAndVarDefs;\n    if (node.kind !== 'Field' || node.name.value !== this.fieldName) return false;\n    const root = parents[0];\n    if (\n      root.kind === 'OperationDefinition' &&\n      this.rootTypes.indexOf(root.operation as RootType) === -1\n    ) {\n      return false;\n    }\n    if (root.kind === 'FragmentDefinition' && this.rootTypes.indexOf('fragment') === -1) {\n      return false;\n    }\n    if (\n      this.matchConditions &&\n      !this.matchConditions.find(condition => condition(nodeAndVarDefs, parents))\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs): NodeAndVarDefs {\n    return nodeAndVarDefs;\n  }\n\n  public rewriteVariables(nodeAndVarDefs: NodeAndVarDefs, variables: Variables): Variables {\n    return variables;\n  }\n\n  public rewriteResponse(response: any, key: string | number): any {\n    return response;\n  }\n}\n\nexport default Rewriter;\n","import { ASTNode, FieldNode } from 'graphql';\r\nimport { NodeAndVarDefs } from '../ast';\r\nimport Rewriter, { RewriterOpts } from './Rewriter';\r\n\r\ninterface IFieldArgNameRewriterOpts extends RewriterOpts {\r\n  oldArgName: string;\r\n  newArgName: string;\r\n}\r\n\r\n/**\r\n * Rewriter which replaces the name of a single argument of a field\r\n * ex: change from thingID: ID! to thingId: ID!\r\n */\r\nclass FieldArgNameRewriter extends Rewriter {\r\n  protected oldArgName: string;\r\n  protected newArgName: string;\r\n\r\n  constructor(options: IFieldArgNameRewriterOpts) {\r\n    super(options);\r\n    this.oldArgName = options.oldArgName;\r\n    this.newArgName = options.newArgName;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    // is this a field with the correct arguments?\r\n    if (!node.arguments) return false;\r\n    // is there an argument with the correct name?\r\n    return !!node.arguments.find(arg => arg.name.value === this.oldArgName);\r\n  }\r\n\r\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\r\n    const newArguments = ((node as FieldNode).arguments || []).map(argument => {\r\n      if (argument.name.value === this.oldArgName) {\r\n        return { ...argument, name: { ...argument.name, value: this.newArgName } };\r\n      }\r\n      return argument;\r\n    });\r\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\r\n  }\r\n}\r\n\r\nexport default FieldArgNameRewriter;\r\n","import { ArgumentNode, ASTNode, FieldNode, ObjectFieldNode } from 'graphql';\r\nimport { NodeAndVarDefs } from '../ast';\r\nimport Rewriter, { RewriterOpts } from './Rewriter';\r\n\r\ninterface FieldArgsToInputTypeRewriterOpts extends RewriterOpts {\r\n  argNames: string[];\r\n  inputArgName?: string;\r\n}\r\n\r\n/**\r\n * Rewriter which replaces the args to a field with an input type\r\n * ex: change from field(id: $id, arg2: $arg2) to field(input: { id: $id, arg2: $arg2 })\r\n */\r\nclass FieldArgsToInputTypeRewriter extends Rewriter {\r\n  protected argNames: string[];\r\n  protected inputArgName: string = 'input';\r\n\r\n  constructor(options: FieldArgsToInputTypeRewriterOpts) {\r\n    super(options);\r\n    this.fieldName = options.fieldName;\r\n    this.argNames = options.argNames;\r\n    if (options.inputArgName) this.inputArgName = options.inputArgName;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    // is this a field with the correct fieldName and arguments?\r\n    if (node.name.value !== this.fieldName || !node.arguments) return false;\r\n    // if there's already an input type in this field, skip it\r\n    if (node.arguments.find(arg => arg.name.value === this.inputArgName)) {\r\n      return false;\r\n    }\r\n    // is there an argument with the correct name?\r\n    return !!node.arguments.find(arg => this.argNames.indexOf(arg.name.value) >= 0);\r\n  }\r\n\r\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\r\n    const argsToNest = ((node as FieldNode).arguments || []).filter(\r\n      argument => this.argNames.indexOf(argument.name.value) >= 0\r\n    );\r\n    const newArguments = ((node as FieldNode).arguments || []).filter(\r\n      argument => this.argNames.indexOf(argument.name.value) === -1\r\n    );\r\n    const inputArgument: ArgumentNode = {\r\n      kind: 'Argument',\r\n      name: { kind: 'Name', value: this.inputArgName },\r\n      value: {\r\n        kind: 'ObjectValue',\r\n        fields: argsToNest.map(\r\n          (arg): ObjectFieldNode => ({\r\n            kind: 'ObjectField',\r\n            name: arg.name,\r\n            value: arg.value\r\n          })\r\n        )\r\n      }\r\n    };\r\n    newArguments.push(inputArgument);\r\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\r\n  }\r\n}\r\n\r\nexport default FieldArgsToInputTypeRewriter;\r\n","import { ArgumentNode, ASTNode, FieldNode, parseType, TypeNode, VariableNode } from 'graphql';\r\nimport { NodeAndVarDefs, nodesMatch } from '../ast';\r\nimport { identifyFunc } from '../utils';\r\nimport Rewriter, { RewriterOpts, Variables } from './Rewriter';\r\n\r\ninterface FieldArgTypeRewriterOpts extends RewriterOpts {\r\n  argName: string;\r\n  oldType: string;\r\n  newType: string;\r\n  coerceVariable?: (variable: any) => any;\r\n}\r\n\r\n/**\r\n * Rewriter which replaces the type of a single argument of a field\r\n * ex: change from id: String! to id: ID!\r\n */\r\nclass FieldArgTypeRewriter extends Rewriter {\r\n  protected argName: string;\r\n  protected oldTypeNode: TypeNode;\r\n  protected newTypeNode: TypeNode;\r\n  protected coerceVariable: (variable: any) => any;\r\n\r\n  constructor(options: FieldArgTypeRewriterOpts) {\r\n    super(options);\r\n    this.argName = options.argName;\r\n    this.oldTypeNode = parseType(options.oldType);\r\n    this.newTypeNode = parseType(options.newType);\r\n    this.coerceVariable = options.coerceVariable || identifyFunc;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    const { variableDefinitions } = nodeAndVars;\r\n    // is this a field with the correct fieldName and arguments?\r\n    if (node.kind !== 'Field') return false;\r\n    if (node.name.value !== this.fieldName || !node.arguments) return false;\r\n    // is there an argument with the correct name and type in a variable?\r\n    const matchingArgument = node.arguments.find(arg => arg.name.value === this.argName);\r\n    if (!matchingArgument || matchingArgument.value.kind !== 'Variable') return false;\r\n    const varRef = matchingArgument.value.name.value;\r\n\r\n    // does the referenced variable have the correct type?\r\n    for (const varDefinition of variableDefinitions) {\r\n      if (varDefinition.variable.name.value === varRef) {\r\n        return nodesMatch(this.oldTypeNode, varDefinition.type);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\r\n    const varRefName = this.extractMatchingVarRefName(node as FieldNode);\r\n    const newVarDefs = variableDefinitions.map(varDef => {\r\n      if (varDef.variable.name.value !== varRefName) return varDef;\r\n      return { ...varDef, type: this.newTypeNode };\r\n    });\r\n    return { node, variableDefinitions: newVarDefs };\r\n  }\r\n\r\n  public rewriteVariables({ node }: NodeAndVarDefs, variables: Variables) {\r\n    if (!variables) return variables;\r\n    const varRefName = this.extractMatchingVarRefName(node as FieldNode);\r\n    return { ...variables, [varRefName]: this.coerceVariable(variables[varRefName]) };\r\n  }\r\n\r\n  private extractMatchingVarRefName(node: FieldNode) {\r\n    const matchingArgument = (node.arguments || []).find(arg => arg.name.value === this.argName);\r\n    return ((matchingArgument as ArgumentNode).value as VariableNode).name.value;\r\n  }\r\n}\r\n\r\nexport default FieldArgTypeRewriter;\r\n","import { ASTNode, FieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface NestFieldOutputsRewriterOpts extends RewriterOpts {\n  newOutputName: string;\n  outputsToNest: string[];\n}\n\n/**\n * Rewriter which nests output fields inside of a new output object\n * ex: change from `field { output1, output2 }` to `field { nestedOutputs { output1, output 2 } }`\n */\nclass NestFieldOutputsRewriter extends Rewriter {\n  protected newOutputName: string;\n  protected outputsToNest: string[];\n\n  constructor(options: NestFieldOutputsRewriterOpts) {\n    super(options);\n    this.newOutputName = options.newOutputName;\n    this.outputsToNest = options.outputsToNest;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct selections?\n    if (!node.selectionSet) return false;\n    // if `newOutputName` already exists as an output, skip it\n    if (\n      node.selectionSet.selections.find(\n        output => output.kind === 'Field' && output.name.value === this.newOutputName\n      )\n    ) {\n      return false;\n    }\n    // is there an output with a matching name?\n    return !!node.selectionSet.selections.find(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    if (!node.selectionSet) return nodeAndVarDefs;\n    const outputsToNest = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n    const newOutputs = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) === -1\n    );\n    const nestedOutput: FieldNode = {\n      kind: 'Field',\n      name: { kind: 'Name', value: this.newOutputName },\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: outputsToNest\n      }\n    };\n    newOutputs.push(nestedOutput);\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet: { ...node.selectionSet, selections: newOutputs } }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string | number) {\n    const pathResponse = response[key];\n\n    if (typeof pathResponse === 'object') {\n      // undo the nesting in the response so it matches the original query\n      if (\n        pathResponse[this.newOutputName] &&\n        typeof pathResponse[this.newOutputName] === 'object'\n      ) {\n        const rewrittenResponse = { ...pathResponse, ...pathResponse[this.newOutputName] };\n        delete rewrittenResponse[this.newOutputName];\n        response[key] = rewrittenResponse;\n      }\n    }\n\n    return response;\n  }\n}\n\nexport default NestFieldOutputsRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface ScalarFieldToObjectFieldRewriterOpts extends RewriterOpts {\n  objectFieldName: string;\n}\n\n/**\n * Rewriter which nests output fields inside of a new output object\n * ex: change from `field { subField }` to `field { subField { objectfield } }`\n */\nclass ScalarFieldToObjectFieldRewriter extends Rewriter {\n  protected objectFieldName: string;\n\n  constructor(options: ScalarFieldToObjectFieldRewriterOpts) {\n    super(options);\n    this.objectFieldName = options.objectFieldName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // make sure there's no subselections on this field\n    if (node.selectionSet) return false;\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    // if there's a subselection already, just return\n    if (node.selectionSet) return nodeAndVarDefs;\n\n    const selectionSet: SelectionSetNode = {\n      kind: 'SelectionSet',\n      selections: [\n        {\n          kind: 'Field',\n          name: { kind: 'Name', value: this.objectFieldName }\n        }\n      ]\n    };\n\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string | number) {\n    if (typeof response === 'object') {\n      const pathResponse = response[key];\n\n      // undo the nesting in the response so it matches the original query\n      response[key] = pathResponse[this.objectFieldName];\n    }\n\n    return response;\n  }\n}\n\nexport default ScalarFieldToObjectFieldRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\r\nimport { NodeAndVarDefs } from '../ast';\r\nimport Rewriter, { RewriterOpts } from './Rewriter';\r\n\r\ninterface ObjectField {\r\n  name: string;\r\n  subfields?: ObjectField[];\r\n}\r\n\r\ninterface JsonToTypedObjectRewriterOpts extends RewriterOpts {\r\n  objectFields: ObjectField[];\r\n}\r\n\r\nexport default class JsonToTypedObjectRewriter extends Rewriter {\r\n  protected objectFields: ObjectField[];\r\n\r\n  constructor({ fieldName, objectFields }: JsonToTypedObjectRewriterOpts) {\r\n    super({ fieldName });\r\n    this.objectFields = objectFields;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    // make sure there's no subselections on this field\r\n    if (node.selectionSet) return false;\r\n    return true;\r\n  }\r\n\r\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs): NodeAndVarDefs {\r\n    const node = nodeAndVarDefs.node as FieldNode;\r\n    const { variableDefinitions } = nodeAndVarDefs;\r\n    // if there's a subselection already, just return\r\n    if (node.selectionSet) return nodeAndVarDefs;\r\n\r\n    const selectionSet = this.generateSelectionSet(this.objectFields);\r\n\r\n    return {\r\n      variableDefinitions,\r\n      node: { ...node, selectionSet }\r\n    } as NodeAndVarDefs;\r\n  }\r\n\r\n  private generateSelectionSet(fields: ObjectField[]): SelectionSetNode {\r\n    return {\r\n      kind: 'SelectionSet',\r\n      selections: fields.map(({ name, subfields }) => ({\r\n        kind: 'Field',\r\n        name: { kind: 'Name', value: name },\r\n        ...(subfields && {\r\n          selectionSet: this.generateSelectionSet(subfields)\r\n        })\r\n      }))\r\n    } as SelectionSetNode;\r\n  }\r\n}\r\n","import { FragmentDefinitionNode } from 'graphql';\r\nimport { extractPath } from '../ast';\r\nimport matchCondition from './matchCondition';\r\nexport interface FragmentMatchConditionOpts {\r\n  fragmentNames?: string[];\r\n  fragmentTypes?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\nconst fragmentMatchCondition = ({\r\n  fragmentNames,\r\n  fragmentTypes,\r\n  pathRegexes\r\n}: FragmentMatchConditionOpts = {}): matchCondition => {\r\n  return ({ node }, parents) => {\r\n    const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\r\n      | FragmentDefinitionNode\r\n      | undefined;\r\n    if (!fragmentDef) return false;\r\n\r\n    if (fragmentNames && !fragmentNames.includes(fragmentDef.name.value)) {\r\n      return false;\r\n    }\r\n\r\n    if (fragmentTypes && !fragmentTypes.includes(fragmentDef.typeCondition.name.value)) {\r\n      return false;\r\n    }\r\n\r\n    if (pathRegexes) {\r\n      const pathStr = extractPath([...parents, node]).join('.');\r\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n};\r\n\r\nexport default fragmentMatchCondition;\r\n","import { OperationDefinitionNode } from 'graphql';\r\nimport { extractPath } from '../ast';\r\nimport matchCondition from './matchCondition';\r\n\r\n/** @hidden */\r\nexport interface OperationMatchConditionOpts {\r\n  operationNames?: string[];\r\n  operationTypes?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\n/** @hidden */\r\nexport default ({\r\n  operationNames,\r\n  operationTypes,\r\n  pathRegexes\r\n}: OperationMatchConditionOpts = {}): matchCondition => {\r\n  return ({ node }, parents) => {\r\n    const operationDef = parents.find(({ kind }) => kind === 'OperationDefinition') as\r\n      | OperationDefinitionNode\r\n      | undefined;\r\n\r\n    if (!operationDef) return false;\r\n\r\n    if (operationNames) {\r\n      if (!operationDef.name || !operationNames.includes(operationDef.name.value)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (operationTypes && !operationTypes.includes(operationDef.operation)) {\r\n      return false;\r\n    }\r\n\r\n    if (pathRegexes) {\r\n      const pathStr = extractPath([...parents, node]).join('.');\r\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n};\r\n","import matchCondition from './matchCondition';\r\nimport operationMatchCondition from './operationMatchCondition';\r\nexport interface QueryMatchConditionOpts {\r\n  queryNames?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\nconst queryMatchCondition = ({\r\n  queryNames,\r\n  pathRegexes\r\n}: QueryMatchConditionOpts = {}): matchCondition => {\r\n  return operationMatchCondition({\r\n    pathRegexes,\r\n    operationNames: queryNames,\r\n    operationTypes: ['query']\r\n  });\r\n};\r\n\r\nexport default queryMatchCondition;\r\n","import matchCondition from './matchCondition';\r\nimport operationMatchCondition from './operationMatchCondition';\r\nexport interface MutationMatchConditionOpts {\r\n  mutationNames?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\nconst mutationMatchCondition = ({\r\n  mutationNames,\r\n  pathRegexes\r\n}: MutationMatchConditionOpts = {}): matchCondition => {\r\n  return operationMatchCondition({\r\n    pathRegexes,\r\n    operationNames: mutationNames,\r\n    operationTypes: ['mutation']\r\n  });\r\n};\r\n\r\nexport default mutationMatchCondition;\r\n"],"names":["tslib_1.__extends"],"mappings":"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"}
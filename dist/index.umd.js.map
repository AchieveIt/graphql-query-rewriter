{"version":3,"file":"index.umd.js","sources":["../src/utils.ts","../src/ast.ts","../src/RewriteHandler.ts","../src/rewriters/Rewriter.ts","../src/rewriters/FieldArgNameRewriter.ts","../src/rewriters/FieldArgsToInputTypeRewriter.ts","../src/rewriters/FieldArgTypeRewriter.ts","../src/rewriters/NestFieldOutputsRewriter.ts","../src/rewriters/ScalarFieldToObjectFieldRewriter.ts","../src/rewriters/JsonToTypedObjectRewriter.ts","../src/matchConditions/fragmentMatchCondition.ts","../src/matchConditions/operationMatchCondition.ts","../src/matchConditions/queryMatchCondition.ts","../src/matchConditions/mutationMatchCondition.ts"],"sourcesContent":["/** @hidden */\r\nexport const identifyFunc = <T>(val: T) => val;\r\n\r\n/** @hidden */\r\nexport const pushToArrayAtKey = <T>(mapping: { [key: string]: T[] }, key: string, val: T): void => {\r\n  if (!mapping[key]) mapping[key] = [];\r\n  mapping[key].push(val);\r\n};\r\n","import { ASTNode, DocumentNode, FragmentDefinitionNode, VariableDefinitionNode } from 'graphql';\nimport { pushToArrayAtKey } from './utils';\n\nconst ignoreKeys = new Set(['loc']);\n\n/** @hidden */\nexport const nodesMatch = (node1: ASTNode, node2: ASTNode): boolean => {\n  for (const key of Object.keys(node1)) {\n    if (ignoreKeys.has(key)) continue;\n    const val1 = (node1 as any)[key];\n    const val2 = (node2 as any)[key];\n    if (val1 && !val2) return false;\n    if (Array.isArray(val1)) {\n      if (val1.length !== val2.length) return false;\n      for (let i = 0; i < val1.length; i++) {\n        if (!nodesMatch(val1[i], val2[i])) return false;\n      }\n    } else if (typeof val1 === 'object') {\n      if (!nodesMatch(val1, val2)) return false;\n    } else if (val1 !== val2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/** @hidden */\nexport interface NodeAndVarDefs {\n  node: ASTNode;\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>;\n}\n\n/** @hidden */\nexport interface FragmentPathMap {\n  [fragmentName: string]: ReadonlyArray<ReadonlyArray<string>>;\n}\n\n/** @hidden */\ninterface MutableFragmentPathMap {\n  [fragmentName: string]: Array<ReadonlyArray<string>>;\n}\n\n/** @hidden */\nexport class FragmentTracer {\n  private fragmentPathMap?: FragmentPathMap;\n  private doc: DocumentNode;\n\n  constructor(doc: DocumentNode) {\n    this.doc = doc;\n  }\n\n  public getPathsToFragment(fragmentName: string): ReadonlyArray<ReadonlyArray<string>> {\n    if (!this.fragmentPathMap) {\n      this.fragmentPathMap = this.buildFragmentPathMap();\n    }\n    return this.fragmentPathMap[fragmentName] || [];\n  }\n\n  // prepend the paths from the original document into this fragment to the inner fragment paths\n  public prependFragmentPaths(\n    fragmentName: string,\n    pathWithinFragment: ReadonlyArray<string>\n  ): ReadonlyArray<ReadonlyArray<string>> {\n    return this.getPathsToFragment(fragmentName).map(path => [...path, ...pathWithinFragment]);\n  }\n\n  private getFragmentDefs(): ReadonlyArray<FragmentDefinitionNode> {\n    return this.doc.definitions.filter(\n      ({ kind }) => kind === 'FragmentDefinition'\n    ) as FragmentDefinitionNode[];\n  }\n\n  private getFragmentPartialPathMap(startNode: ASTNode): MutableFragmentPathMap {\n    const partialPathMap: MutableFragmentPathMap = {};\n    const recursivelyBuildFragmentPaths = (node: ASTNode, curParents: ReadonlyArray<ASTNode>) => {\n      if (node.kind === 'FragmentSpread') {\n        pushToArrayAtKey(partialPathMap, node.name.value, extractPath(curParents));\n      }\n      const nextParents = [...curParents, node];\n      if ('selectionSet' in node && node.selectionSet) {\n        for (const selection of node.selectionSet.selections) {\n          recursivelyBuildFragmentPaths(selection, nextParents);\n        }\n      }\n    };\n    recursivelyBuildFragmentPaths(startNode, []);\n    return partialPathMap;\n  }\n\n  private mergeFragmentPaths(\n    fragmentName: string,\n    paths: Array<ReadonlyArray<string>>,\n    fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap }\n  ) {\n    const mergedPaths: MutableFragmentPathMap = {};\n\n    const resursivelyBuildMergedPathsMap = (\n      curFragmentName: string,\n      curPaths: Array<ReadonlyArray<string>>,\n      seenFragments: ReadonlySet<string>\n    ) => {\n      // recursive fragments are invalid graphQL - just exit here. otherwise this will be an infinite loop\n      if (seenFragments.has(curFragmentName)) return;\n      const nextSeenFragments = new Set(seenFragments);\n      nextSeenFragments.add(curFragmentName);\n      const nextPartialPaths = fragmentPartialPathsMap[curFragmentName];\n      // if there are not other fragments nested inside of this fragment, we're done\n      if (!nextPartialPaths) return;\n\n      for (const [childFragmentName, childFragmentPaths] of Object.entries(nextPartialPaths)) {\n        for (const path of curPaths) {\n          const mergedChildPaths: Array<ReadonlyArray<string>> = [];\n          for (const childPath of childFragmentPaths) {\n            const mergedPath = [...path, ...childPath];\n            mergedChildPaths.push(mergedPath);\n            pushToArrayAtKey(mergedPaths, childFragmentName, mergedPath);\n          }\n          resursivelyBuildMergedPathsMap(childFragmentName, mergedChildPaths, nextSeenFragments);\n        }\n      }\n    };\n\n    resursivelyBuildMergedPathsMap(fragmentName, paths, new Set());\n    return mergedPaths;\n  }\n\n  private buildFragmentPathMap(): FragmentPathMap {\n    const mainOperation = this.doc.definitions.find(node => node.kind === 'OperationDefinition');\n    if (!mainOperation) return {};\n\n    // partial paths are the paths inside of each fragmnt to other fragments\n    const fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap } = {};\n    for (const fragmentDef of this.getFragmentDefs()) {\n      fragmentPartialPathsMap[fragmentDef.name.value] = this.getFragmentPartialPathMap(fragmentDef);\n    }\n\n    // start with the direct paths to fragments inside of the main operation\n    const simpleFragmentPathMap: MutableFragmentPathMap = this.getFragmentPartialPathMap(\n      mainOperation\n    );\n    const fragmentPathMap: MutableFragmentPathMap = { ...simpleFragmentPathMap };\n    // next, we'll recursively trace the partials into their subpartials to fill out all possible paths to each fragment\n    for (const [fragmentName, simplePaths] of Object.entries(simpleFragmentPathMap)) {\n      const mergedFragmentPathsMap = this.mergeFragmentPaths(\n        fragmentName,\n        simplePaths,\n        fragmentPartialPathsMap\n      );\n      for (const [mergedFragmentName, mergedFragmentPaths] of Object.entries(\n        mergedFragmentPathsMap\n      )) {\n        fragmentPathMap[mergedFragmentName] = [\n          ...(fragmentPathMap[mergedFragmentName] || []),\n          ...mergedFragmentPaths\n        ];\n      }\n    }\n\n    return fragmentPathMap;\n  }\n}\n\n/**\n * Walk the document add rewrite nodes along the way\n * @param doc\n * @param callback Called on each node, and returns a new rewritten node\n * @hidden\n */\nexport const rewriteDoc = (\n  doc: DocumentNode,\n  callback: (nodeAndVars: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>) => NodeAndVarDefs\n): DocumentNode => {\n  let variableDefinitions = extractVariableDefinitions(doc);\n  const walkRecursive = (\n    curNodeAndVars: NodeAndVarDefs,\n    curParents: ReadonlyArray<ASTNode>\n  ): ASTNode => {\n    const nextNodeAndVars = callback(curNodeAndVars, curParents);\n    variableDefinitions = nextNodeAndVars.variableDefinitions;\n    const node = nextNodeAndVars.node;\n    const nextParents = [...curParents, node];\n    for (const key of Object.keys(node)) {\n      if (key === 'loc') continue;\n      const val = (node as any)[key];\n      if (Array.isArray(val)) {\n        (node as any)[key] = val.map(elm => {\n          if (typeof elm === 'object') {\n            const next: NodeAndVarDefs = {\n              variableDefinitions,\n              node: elm\n            };\n            return walkRecursive(next, nextParents);\n          }\n          return elm;\n        });\n      } else if (typeof val === 'object') {\n        const next: NodeAndVarDefs = {\n          variableDefinitions,\n          node: val\n        };\n        (node as any)[key] = walkRecursive(next, nextParents);\n      }\n    }\n    return node;\n  };\n\n  const root: NodeAndVarDefs = {\n    variableDefinitions,\n    node: doc\n  };\n  const rewrittenDoc = walkRecursive(root, []) as DocumentNode;\n  return replaceVariableDefinitions(rewrittenDoc, variableDefinitions);\n};\n\n/** @hidden */\nexport const extractVariableDefinitions = (\n  doc: DocumentNode\n): ReadonlyArray<VariableDefinitionNode> => {\n  for (const def of doc.definitions) {\n    if (def.kind === 'OperationDefinition') {\n      return def.variableDefinitions || [];\n    }\n  }\n  return [];\n};\n\n/** @hidden */\nexport const replaceVariableDefinitions = (\n  doc: DocumentNode,\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>\n): DocumentNode => {\n  const definitions = doc.definitions.map(def => {\n    if (def.kind === 'OperationDefinition') {\n      return { ...def, variableDefinitions };\n    }\n    return def;\n  });\n  return { ...doc, definitions };\n};\n\n/**\n * return the path that will be returned in the response from from the chain of parents\n */\n/** @hidden */\nexport const extractPath = (parents: ReadonlyArray<ASTNode>): ReadonlyArray<string> => {\n  const path: string[] = [];\n  parents.forEach(parent => {\n    if (parent.kind === 'Field') {\n      path.push(parent.name.value);\n    }\n  });\n  return path;\n};\n\n/** @hidden */\ninterface ResultObj {\n  [key: string]: any;\n}\n\n/** @hidden */\nexport const rewriteResultsAtPath = (\n  results: ResultObj,\n  path: ReadonlyArray<string>,\n  callback: (parentResult: any, key: string | number) => any\n): ResultObj => {\n  if (path.length === 0) return results;\n\n  const curPathElm = path[0];\n  const newResults = { ...results };\n  const curResults = results[curPathElm];\n\n  if (path.length === 1) {\n    if (Array.isArray(curResults)) {\n      return curResults.map((_, index) => {\n        const newValue = callback(curResults, index);\n        return newValue;\n      });\n    }\n\n    return callback(results, curPathElm);\n  }\n\n  const remainingPath = path.slice(1);\n  // if the path stops here, just return results without any rewriting\n  if (curResults === undefined || curResults === null) return results;\n\n  if (Array.isArray(curResults)) {\n    newResults[curPathElm] = curResults.map(result =>\n      rewriteResultsAtPath(result, remainingPath, callback)\n    );\n  } else {\n    newResults[curPathElm] = rewriteResultsAtPath(curResults, remainingPath, callback);\n  }\n\n  return newResults;\n};\n","import { FragmentDefinitionNode, parse, print } from 'graphql';\r\nimport { extractPath, FragmentTracer, rewriteDoc, rewriteResultsAtPath } from './ast';\r\nimport Rewriter, { Variables } from './rewriters/Rewriter';\r\n\r\ninterface RewriterMatch {\r\n  rewriter: Rewriter;\r\n  paths: ReadonlyArray<ReadonlyArray<string>>;\r\n}\r\n\r\n/**\r\n * Create a new instance of this class for each request that needs to be processed\r\n * This class handles rewriting the query and the reponse according to the rewriters passed in\r\n */\r\nexport default class RewriteHandler {\r\n  public matches: RewriterMatch[] = [];\r\n\r\n  private rewriters: Rewriter[];\r\n  private hasProcessedRequest: boolean = false;\r\n  private hasProcessedResponse: boolean = false;\r\n\r\n  constructor(rewriters: Rewriter[]) {\r\n    this.rewriters = rewriters;\r\n  }\r\n\r\n  /**\r\n   * Call this on a graphQL request in middleware before passing on to the real graphql processor\r\n   * @param query The graphQL query\r\n   * @param variables The variables map for the graphQL query\r\n   */\r\n  public rewriteRequest(query: string, variables?: Variables) {\r\n    if (this.hasProcessedRequest) throw new Error('This handler has already rewritten a request');\r\n    this.hasProcessedRequest = true;\r\n    const doc = parse(query);\r\n    const fragmentTracer = new FragmentTracer(doc);\r\n    let rewrittenVariables = variables;\r\n    const rewrittenDoc = rewriteDoc(doc, (nodeAndVars, parents) => {\r\n      let rewrittenNodeAndVars = nodeAndVars;\r\n      this.rewriters.forEach(rewriter => {\r\n        const isMatch = rewriter.matches(nodeAndVars, parents);\r\n        if (isMatch) {\r\n          rewrittenVariables = rewriter.rewriteVariables(rewrittenNodeAndVars, rewrittenVariables);\r\n          rewrittenNodeAndVars = rewriter.rewriteQuery(rewrittenNodeAndVars);\r\n          const simplePath = extractPath([...parents, rewrittenNodeAndVars.node]);\r\n          let paths: ReadonlyArray<ReadonlyArray<string>> = [simplePath];\r\n          const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\r\n            | FragmentDefinitionNode\r\n            | undefined;\r\n          if (fragmentDef) {\r\n            paths = fragmentTracer.prependFragmentPaths(fragmentDef.name.value, simplePath);\r\n          }\r\n          this.matches.push({\r\n            rewriter,\r\n            paths\r\n          });\r\n        }\r\n        return isMatch;\r\n      });\r\n      return rewrittenNodeAndVars;\r\n    });\r\n\r\n    return { query: print(rewrittenDoc), variables: rewrittenVariables };\r\n  }\r\n\r\n  /**\r\n   * Call this on the response returned from graphQL before passing it back to the client\r\n   * This will change the output to match what the original query requires\r\n   * @param response The graphQL response object\r\n   */\r\n  public rewriteResponse(response: any) {\r\n    if (this.hasProcessedResponse) throw new Error('This handler has already returned a response');\r\n    this.hasProcessedResponse = true;\r\n    let rewrittenResponse = response;\r\n    this.matches.reverse().forEach(({ rewriter, paths }) => {\r\n      paths.forEach(path => {\r\n        rewrittenResponse = rewriteResultsAtPath(rewrittenResponse, path, (parentResponse, key) =>\r\n          rewriter.rewriteResponse(parentResponse, key)\r\n        );\r\n      });\r\n    });\r\n    return rewrittenResponse;\r\n  }\r\n}\r\n","import { ASTNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport matchCondition from '../matchConditions/matchCondition';\n\nexport type Variables = { [key: string]: any } | undefined;\nexport type RootType = 'query' | 'mutation' | 'fragment';\n\nexport interface RewriterOpts {\n  fieldName: string;\n  rootTypes?: RootType[];\n  matchConditions?: matchCondition[];\n}\n\n/**\n * Abstract base Rewriter class\n * Extend this class and overwrite its methods to create a new rewriter\n */\nabstract class Rewriter {\n  protected fieldName: string;\n  protected rootTypes: RootType[] = ['query', 'mutation', 'fragment'];\n  protected matchConditions?: matchCondition[];\n\n  constructor({ fieldName, rootTypes, matchConditions }: RewriterOpts) {\n    this.fieldName = fieldName;\n    this.matchConditions = matchConditions;\n    if (rootTypes) this.rootTypes = rootTypes;\n  }\n\n  public matches(nodeAndVarDefs: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>): boolean {\n    const { node } = nodeAndVarDefs;\n    if (node.kind !== 'Field' || node.name.value !== this.fieldName) return false;\n    const root = parents[0];\n    if (\n      root.kind === 'OperationDefinition' &&\n      this.rootTypes.indexOf(root.operation as RootType) === -1\n    ) {\n      return false;\n    }\n    if (root.kind === 'FragmentDefinition' && this.rootTypes.indexOf('fragment') === -1) {\n      return false;\n    }\n    if (\n      this.matchConditions &&\n      !this.matchConditions.find(condition => condition(nodeAndVarDefs, parents))\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs): NodeAndVarDefs {\n    return nodeAndVarDefs;\n  }\n\n  public rewriteVariables(nodeAndVarDefs: NodeAndVarDefs, variables: Variables): Variables {\n    return variables;\n  }\n\n  public rewriteResponse(response: any, key: string | number): any {\n    return response;\n  }\n}\n\nexport default Rewriter;\n","import { ASTNode, FieldNode } from 'graphql';\r\nimport { NodeAndVarDefs } from '../ast';\r\nimport Rewriter, { RewriterOpts } from './Rewriter';\r\n\r\ninterface IFieldArgNameRewriterOpts extends RewriterOpts {\r\n  oldArgName: string;\r\n  newArgName: string;\r\n}\r\n\r\n/**\r\n * Rewriter which replaces the name of a single argument of a field\r\n * ex: change from thingID: ID! to thingId: ID!\r\n */\r\nclass FieldArgNameRewriter extends Rewriter {\r\n  protected oldArgName: string;\r\n  protected newArgName: string;\r\n\r\n  constructor(options: IFieldArgNameRewriterOpts) {\r\n    super(options);\r\n    this.oldArgName = options.oldArgName;\r\n    this.newArgName = options.newArgName;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    // is this a field with the correct arguments?\r\n    if (!node.arguments) return false;\r\n    // is there an argument with the correct name?\r\n    return !!node.arguments.find(arg => arg.name.value === this.oldArgName);\r\n  }\r\n\r\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\r\n    const newArguments = ((node as FieldNode).arguments || []).map(argument => {\r\n      if (argument.name.value === this.oldArgName) {\r\n        return { ...argument, name: { ...argument.name, value: this.newArgName } };\r\n      }\r\n      return argument;\r\n    });\r\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\r\n  }\r\n}\r\n\r\nexport default FieldArgNameRewriter;\r\n","import { ArgumentNode, ASTNode, FieldNode, ObjectFieldNode } from 'graphql';\r\nimport { NodeAndVarDefs } from '../ast';\r\nimport Rewriter, { RewriterOpts } from './Rewriter';\r\n\r\ninterface FieldArgsToInputTypeRewriterOpts extends RewriterOpts {\r\n  argNames: string[];\r\n  inputArgName?: string;\r\n}\r\n\r\n/**\r\n * Rewriter which replaces the args to a field with an input type\r\n * ex: change from field(id: $id, arg2: $arg2) to field(input: { id: $id, arg2: $arg2 })\r\n */\r\nclass FieldArgsToInputTypeRewriter extends Rewriter {\r\n  protected argNames: string[];\r\n  protected inputArgName: string = 'input';\r\n\r\n  constructor(options: FieldArgsToInputTypeRewriterOpts) {\r\n    super(options);\r\n    this.fieldName = options.fieldName;\r\n    this.argNames = options.argNames;\r\n    if (options.inputArgName) this.inputArgName = options.inputArgName;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    // is this a field with the correct fieldName and arguments?\r\n    if (node.name.value !== this.fieldName || !node.arguments) return false;\r\n    // if there's already an input type in this field, skip it\r\n    if (node.arguments.find(arg => arg.name.value === this.inputArgName)) {\r\n      return false;\r\n    }\r\n    // is there an argument with the correct name?\r\n    return !!node.arguments.find(arg => this.argNames.indexOf(arg.name.value) >= 0);\r\n  }\r\n\r\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\r\n    const argsToNest = ((node as FieldNode).arguments || []).filter(\r\n      argument => this.argNames.indexOf(argument.name.value) >= 0\r\n    );\r\n    const newArguments = ((node as FieldNode).arguments || []).filter(\r\n      argument => this.argNames.indexOf(argument.name.value) === -1\r\n    );\r\n    const inputArgument: ArgumentNode = {\r\n      kind: 'Argument',\r\n      name: { kind: 'Name', value: this.inputArgName },\r\n      value: {\r\n        kind: 'ObjectValue',\r\n        fields: argsToNest.map(\r\n          (arg): ObjectFieldNode => ({\r\n            kind: 'ObjectField',\r\n            name: arg.name,\r\n            value: arg.value\r\n          })\r\n        )\r\n      }\r\n    };\r\n    newArguments.push(inputArgument);\r\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\r\n  }\r\n}\r\n\r\nexport default FieldArgsToInputTypeRewriter;\r\n","import { ArgumentNode, ASTNode, FieldNode, parseType, TypeNode, VariableNode } from 'graphql';\r\nimport { NodeAndVarDefs, nodesMatch } from '../ast';\r\nimport { identifyFunc } from '../utils';\r\nimport Rewriter, { RewriterOpts, Variables } from './Rewriter';\r\n\r\ninterface FieldArgTypeRewriterOpts extends RewriterOpts {\r\n  argName: string;\r\n  oldType: string;\r\n  newType: string;\r\n  coerceVariable?: (variable: any) => any;\r\n}\r\n\r\n/**\r\n * Rewriter which replaces the type of a single argument of a field\r\n * ex: change from id: String! to id: ID!\r\n */\r\nclass FieldArgTypeRewriter extends Rewriter {\r\n  protected argName: string;\r\n  protected oldTypeNode: TypeNode;\r\n  protected newTypeNode: TypeNode;\r\n  protected coerceVariable: (variable: any) => any;\r\n\r\n  constructor(options: FieldArgTypeRewriterOpts) {\r\n    super(options);\r\n    this.argName = options.argName;\r\n    this.oldTypeNode = parseType(options.oldType);\r\n    this.newTypeNode = parseType(options.newType);\r\n    this.coerceVariable = options.coerceVariable || identifyFunc;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    const { variableDefinitions } = nodeAndVars;\r\n    // is this a field with the correct fieldName and arguments?\r\n    if (node.kind !== 'Field') return false;\r\n    if (node.name.value !== this.fieldName || !node.arguments) return false;\r\n    // is there an argument with the correct name and type in a variable?\r\n    const matchingArgument = node.arguments.find(arg => arg.name.value === this.argName);\r\n    if (!matchingArgument || matchingArgument.value.kind !== 'Variable') return false;\r\n    const varRef = matchingArgument.value.name.value;\r\n\r\n    // does the referenced variable have the correct type?\r\n    for (const varDefinition of variableDefinitions) {\r\n      if (varDefinition.variable.name.value === varRef) {\r\n        return nodesMatch(this.oldTypeNode, varDefinition.type);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\r\n    const varRefName = this.extractMatchingVarRefName(node as FieldNode);\r\n    const newVarDefs = variableDefinitions.map(varDef => {\r\n      if (varDef.variable.name.value !== varRefName) return varDef;\r\n      return { ...varDef, type: this.newTypeNode };\r\n    });\r\n    return { node, variableDefinitions: newVarDefs };\r\n  }\r\n\r\n  public rewriteVariables({ node }: NodeAndVarDefs, variables: Variables) {\r\n    if (!variables) return variables;\r\n    const varRefName = this.extractMatchingVarRefName(node as FieldNode);\r\n    return { ...variables, [varRefName]: this.coerceVariable(variables[varRefName]) };\r\n  }\r\n\r\n  private extractMatchingVarRefName(node: FieldNode) {\r\n    const matchingArgument = (node.arguments || []).find(arg => arg.name.value === this.argName);\r\n    return ((matchingArgument as ArgumentNode).value as VariableNode).name.value;\r\n  }\r\n}\r\n\r\nexport default FieldArgTypeRewriter;\r\n","import { ASTNode, FieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface NestFieldOutputsRewriterOpts extends RewriterOpts {\n  newOutputName: string;\n  outputsToNest: string[];\n}\n\n/**\n * Rewriter which nests output fields inside of a new output object\n * ex: change from `field { output1, output2 }` to `field { nestedOutputs { output1, output 2 } }`\n */\nclass NestFieldOutputsRewriter extends Rewriter {\n  protected newOutputName: string;\n  protected outputsToNest: string[];\n\n  constructor(options: NestFieldOutputsRewriterOpts) {\n    super(options);\n    this.newOutputName = options.newOutputName;\n    this.outputsToNest = options.outputsToNest;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct selections?\n    if (!node.selectionSet) return false;\n    // if `newOutputName` already exists as an output, skip it\n    if (\n      node.selectionSet.selections.find(\n        output => output.kind === 'Field' && output.name.value === this.newOutputName\n      )\n    ) {\n      return false;\n    }\n    // is there an output with a matching name?\n    return !!node.selectionSet.selections.find(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    if (!node.selectionSet) return nodeAndVarDefs;\n    const outputsToNest = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n    const newOutputs = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) === -1\n    );\n    const nestedOutput: FieldNode = {\n      kind: 'Field',\n      name: { kind: 'Name', value: this.newOutputName },\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: outputsToNest\n      }\n    };\n    newOutputs.push(nestedOutput);\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet: { ...node.selectionSet, selections: newOutputs } }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string | number) {\n    const pathResponse = response[key];\n\n    if (typeof pathResponse === 'object') {\n      // undo the nesting in the response so it matches the original query\n      if (\n        pathResponse[this.newOutputName] &&\n        typeof pathResponse[this.newOutputName] === 'object'\n      ) {\n        const rewrittenResponse = { ...pathResponse, ...pathResponse[this.newOutputName] };\n        delete rewrittenResponse[this.newOutputName];\n        response[key] = rewrittenResponse;\n      }\n    }\n\n    return response;\n  }\n}\n\nexport default NestFieldOutputsRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface ScalarFieldToObjectFieldRewriterOpts extends RewriterOpts {\n  objectFieldName: string;\n}\n\n/**\n * Rewriter which nests output fields inside of a new output object\n * ex: change from `field { subField }` to `field { subField { objectfield } }`\n */\nclass ScalarFieldToObjectFieldRewriter extends Rewriter {\n  protected objectFieldName: string;\n\n  constructor(options: ScalarFieldToObjectFieldRewriterOpts) {\n    super(options);\n    this.objectFieldName = options.objectFieldName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // make sure there's no subselections on this field\n    if (node.selectionSet) return false;\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    // if there's a subselection already, just return\n    if (node.selectionSet) return nodeAndVarDefs;\n\n    const selectionSet: SelectionSetNode = {\n      kind: 'SelectionSet',\n      selections: [\n        {\n          kind: 'Field',\n          name: { kind: 'Name', value: this.objectFieldName }\n        }\n      ]\n    };\n\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string | number) {\n    if (typeof response === 'object') {\n      const pathResponse = response[key];\n\n      // undo the nesting in the response so it matches the original query\n      response[key] = pathResponse[this.objectFieldName];\n    }\n\n    return response;\n  }\n}\n\nexport default ScalarFieldToObjectFieldRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\r\nimport { NodeAndVarDefs } from '../ast';\r\nimport Rewriter, { RewriterOpts } from './Rewriter';\r\n\r\ninterface ObjectField {\r\n  name: string;\r\n  subfields?: ObjectField[];\r\n}\r\n\r\ninterface JsonToTypedObjectRewriterOpts extends RewriterOpts {\r\n  objectFields: ObjectField[];\r\n}\r\n\r\nexport default class JsonToTypedObjectRewriter extends Rewriter {\r\n  protected objectFields: ObjectField[];\r\n\r\n  constructor({ fieldName, objectFields }: JsonToTypedObjectRewriterOpts) {\r\n    super({ fieldName });\r\n    this.objectFields = objectFields;\r\n  }\r\n\r\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\r\n    if (!super.matches(nodeAndVars, parents)) return false;\r\n    const node = nodeAndVars.node as FieldNode;\r\n    // make sure there's no subselections on this field\r\n    if (node.selectionSet) return false;\r\n    return true;\r\n  }\r\n\r\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs): NodeAndVarDefs {\r\n    const node = nodeAndVarDefs.node as FieldNode;\r\n    const { variableDefinitions } = nodeAndVarDefs;\r\n    // if there's a subselection already, just return\r\n    if (node.selectionSet) return nodeAndVarDefs;\r\n\r\n    const selectionSet = this.generateSelectionSet(this.objectFields);\r\n\r\n    return {\r\n      variableDefinitions,\r\n      node: { ...node, selectionSet }\r\n    } as NodeAndVarDefs;\r\n  }\r\n\r\n  private generateSelectionSet(fields: ObjectField[]): SelectionSetNode {\r\n    return {\r\n      kind: 'SelectionSet',\r\n      selections: fields.map(({ name, subfields }) => ({\r\n        kind: 'Field',\r\n        name: { kind: 'Name', value: name },\r\n        ...(subfields && {\r\n          selectionSet: this.generateSelectionSet(subfields)\r\n        })\r\n      }))\r\n    } as SelectionSetNode;\r\n  }\r\n}\r\n","import { FragmentDefinitionNode } from 'graphql';\r\nimport { extractPath } from '../ast';\r\nimport matchCondition from './matchCondition';\r\nexport interface FragmentMatchConditionOpts {\r\n  fragmentNames?: string[];\r\n  fragmentTypes?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\nconst fragmentMatchCondition = ({\r\n  fragmentNames,\r\n  fragmentTypes,\r\n  pathRegexes\r\n}: FragmentMatchConditionOpts = {}): matchCondition => {\r\n  return ({ node }, parents) => {\r\n    const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\r\n      | FragmentDefinitionNode\r\n      | undefined;\r\n    if (!fragmentDef) return false;\r\n\r\n    if (fragmentNames && !fragmentNames.includes(fragmentDef.name.value)) {\r\n      return false;\r\n    }\r\n\r\n    if (fragmentTypes && !fragmentTypes.includes(fragmentDef.typeCondition.name.value)) {\r\n      return false;\r\n    }\r\n\r\n    if (pathRegexes) {\r\n      const pathStr = extractPath([...parents, node]).join('.');\r\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n};\r\n\r\nexport default fragmentMatchCondition;\r\n","import { OperationDefinitionNode } from 'graphql';\r\nimport { extractPath } from '../ast';\r\nimport matchCondition from './matchCondition';\r\n\r\n/** @hidden */\r\nexport interface OperationMatchConditionOpts {\r\n  operationNames?: string[];\r\n  operationTypes?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\n/** @hidden */\r\nexport default ({\r\n  operationNames,\r\n  operationTypes,\r\n  pathRegexes\r\n}: OperationMatchConditionOpts = {}): matchCondition => {\r\n  return ({ node }, parents) => {\r\n    const operationDef = parents.find(({ kind }) => kind === 'OperationDefinition') as\r\n      | OperationDefinitionNode\r\n      | undefined;\r\n\r\n    if (!operationDef) return false;\r\n\r\n    if (operationNames) {\r\n      if (!operationDef.name || !operationNames.includes(operationDef.name.value)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (operationTypes && !operationTypes.includes(operationDef.operation)) {\r\n      return false;\r\n    }\r\n\r\n    if (pathRegexes) {\r\n      const pathStr = extractPath([...parents, node]).join('.');\r\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n};\r\n","import matchCondition from './matchCondition';\r\nimport operationMatchCondition from './operationMatchCondition';\r\nexport interface QueryMatchConditionOpts {\r\n  queryNames?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\nconst queryMatchCondition = ({\r\n  queryNames,\r\n  pathRegexes\r\n}: QueryMatchConditionOpts = {}): matchCondition => {\r\n  return operationMatchCondition({\r\n    pathRegexes,\r\n    operationNames: queryNames,\r\n    operationTypes: ['query']\r\n  });\r\n};\r\n\r\nexport default queryMatchCondition;\r\n","import matchCondition from './matchCondition';\r\nimport operationMatchCondition from './operationMatchCondition';\r\nexport interface MutationMatchConditionOpts {\r\n  mutationNames?: string[];\r\n  pathRegexes?: RegExp[];\r\n}\r\n\r\nconst mutationMatchCondition = ({\r\n  mutationNames,\r\n  pathRegexes\r\n}: MutationMatchConditionOpts = {}): matchCondition => {\r\n  return operationMatchCondition({\r\n    pathRegexes,\r\n    operationNames: mutationNames,\r\n    operationTypes: ['mutation']\r\n  });\r\n};\r\n\r\nexport default mutationMatchCondition;\r\n"],"names":["parse","print","tslib_1.__extends","parseType"],"mappings":"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"}